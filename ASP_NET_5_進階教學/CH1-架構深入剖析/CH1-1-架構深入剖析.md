# 第 1 章｜ASP.NET Core 5 架構深入剖析

---

## 1.1 專案結構與啟動流程

🧭 目標：看懂一個 ASP.NET Core 5 專案從「啟動 → 建構主機 → 建管線 → 接請求」的整個旅程。

### 標準專案骨架

```
MyApi/
├─ Controllers/
├─ Models/
├─ Services/
├─ Program.cs
├─ Startup.cs
├─ appsettings.json
├─ appsettings.Development.json
└─ MyApi.csproj
```

### 啟動順序（.NET 5 標準樣式）

1. **Program.cs**：建立 Generic Host（通用主機）→ `CreateHostBuilder(args).Build().Run()`
2. **Startup.cs**：

   * `ConfigureServices`：註冊服務到 DI 容器
   * `Configure`：建置 **Request Pipeline（中介軟體順序）**
3. **Host** 啟動 Kestrel → 監聽連線 → 交給管線處理請求

> 備註：你可能會看到網路上有 `WebApplication` 的範例，那是 .NET 6+ 的「最小化主機模型」。本教材以 .NET 5 的 `Host + Startup` 為主，偶爾會補充對照觀念。

### 範例：最小可運作的 Program + Startup

**Program.cs**

```csharp
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;

public class Program
{
    public static void Main(string[] args)
        => CreateHostBuilder(args).Build().Run();

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args) // 載入環境變數、appsettings*.json、User Secrets（Dev）等
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>(); // 導到 Startup
            });
}
```

**Startup.cs**

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

public class Startup
{
    public Startup(IConfiguration config, IWebHostEnvironment env)
    {
        Configuration = config;
        Environment = env;
    }

    public IConfiguration Configuration { get; }
    public IWebHostEnvironment Environment { get; }

    // 1) 註冊服務
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllers();
        // 其他：DI、DbContext、Options 綁定、Swagger、CORS、Auth 等等
    }

    // 2) 建置中介軟體管線（順序**很重要**）
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment()) app.UseDeveloperExceptionPage();

        app.UseHttpsRedirection();

        app.UseRouting();

        app.UseAuthentication(); // 若有驗證，必須在 Authorization 之前
        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
```

---

## 1.2 依賴反轉（DI）容器

🧩 目標：正確挑選 Service Lifetime、會多介面註冊、掌握工廠/命名風格。

### 服務生命週期（Service Lifetime）

* **Transient**：每次解析都產生新物件，適合無狀態、輕量型服務。
* **Scoped**：同一次 HTTP 請求（Scope）內共享同一實例。**Web API 最常用**。
* **Singleton**：應用程式存活期間只有一份，適合昂貴/執行緒安全的服務。

**示範：註冊與解析**

```csharp
public interface IClock { DateTime Now(); }
public class SystemClock : IClock { public DateTime Now() => DateTime.UtcNow; }

public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient<IClock, SystemClock>();
    services.AddScoped<IMailSender, SmtpMailSender>();
    services.AddSingleton<IAppCache, MemoryAppCache>();
}
```

**多介面註冊（同一實作對應多介面）**

```csharp
public interface IReadRepo {}
public interface IWriteRepo {}
public class EfOrderRepository : IReadRepo, IWriteRepo {}

services.AddScoped<IReadRepo, EfOrderRepository>();
services.AddScoped<IWriteRepo, EfOrderRepository>();
```

**以工廠建立（取決於組態或環境）**

```csharp
services.AddSingleton<IStorage>(sp =>
{
    var cfg = sp.GetRequiredService<IConfiguration>();
    var useLocal = cfg.GetValue<bool>("Storage:UseLocal");
    return useLocal ? new LocalStorage() : new S3Storage(cfg["Storage:S3:Bucket"]);
});
```

**具名（命名）註冊的常見手法**

> ASP.NET Core DI 沒有內建「命名服務」，可透過 **Factory + Key** 或 **字典** 模式達成。

```csharp
public interface IPayGateway { Task PayAsync(); }
public class Ecpay : IPayGateway { /*...*/ public Task PayAsync()=>Task.CompletedTask; }
public class NewebPay : IPayGateway { /*...*/ public Task PayAsync()=>Task.CompletedTask; }

services.AddSingleton<Ecpay>();
services.AddSingleton<NewebPay>();
services.AddSingleton<Func<string, IPayGateway>>(sp => key => key switch
{
    "ecpay"   => sp.GetRequiredService<Ecpay>(),
    "neweb"   => sp.GetRequiredService<NewebPay>(),
    _         => throw new ArgumentOutOfRangeException(nameof(key))
});
```

**在 Controller 使用**

```csharp
[ApiController, Route("api/pay")]
public class PayController : ControllerBase
{
    private readonly Func<string, IPayGateway> _factory;
    public PayController(Func<string, IPayGateway> factory) => _factory = factory;

    [HttpPost("{channel}")]
    public async Task<IActionResult> Pay(string channel)
    {
        var gateway = _factory(channel);
        await gateway.PayAsync();
        return Ok(new { channel, ok = true });
    }
}
```

---

## 1.3 組態（Configuration）

🧰 目標：會讀多來源組態、做強型別綁定、支援熱更新（reload on change），並正確分環境。

### 多來源：JSON、環境變數、User Secrets、命令列

`Host.CreateDefaultBuilder` 會自動載入：

* `appsettings.json` → `appsettings.{Environment}.json`（覆蓋）
* **環境變數**（`ASPNETCORE_ENVIRONMENT`、自訂鍵）
* **User Secrets**（僅開發環境）
* **命令列**（再次覆蓋）

**appsettings.json**

```json
{
  "Smtp": {
    "Host": "smtp.example.com",
    "Port": 587,
    "User": "noreply@example.com"
  },
  "FeatureFlags": {
    "NewCheckout": true
  }
}
```

**強型別綁定 + Options**

```csharp
public class SmtpOptions
{
    public string Host { get; set; } = default!;
    public int Port { get; set; }
    public string User { get; set; } = default!;
}

public void ConfigureServices(IServiceCollection services)
{
    services.Configure<SmtpOptions>(Configuration.GetSection("Smtp"));
    services.AddSingleton(sp => sp.GetRequiredService<IOptionsMonitor<SmtpOptions>>().CurrentValue);
    services.AddControllers();
}
```

**在服務或控制器取用**

```csharp
public class MailService
{
    private readonly SmtpOptions _opt;
    public MailService(SmtpOptions opt) => _opt = opt;

    public string Describe() => $"{_opt.Host}:{_opt.Port} as {_opt.User}";
}
```

**Reload On Change（熱更新）**
只要 `appsettings.json` 有 `reloadOnChange: true`（預設 CreateDefaultBuilder 已啟用），修改檔案即可觸發 `IOptionsMonitor<T>` 值更新。

**分環境設定**

* 設定 `ASPNETCORE_ENVIRONMENT=Development/Staging/Production`
* 建立 `appsettings.Development.json` 覆蓋差異
* 在 `Startup.Configure` 用 `env.IsDevelopment()` 切換行為（如顯示詳細錯誤頁）

---

## 1.4 要求處理管線（Request Pipeline）

🛤️ 目標：理解中介軟體順序對行為的決定性影響，會正確地 **Use / Map / Run**，並玩轉分支與短路。

### Use / Run / Map 的差異

* `app.Use(...)`：**可往下傳遞**，你可以在呼叫 `next()` 前後夾擊請求與回應。
* `app.Run(...)`：**終止點**，不再呼叫下一個中介軟體（短路）。
* `app.Map(path, branchApp => { ... })`：當路徑符合時，**分支管線**。

**最小示範：順序與短路**

```csharp
app.Use(async (ctx, next) =>
{
    Console.WriteLine("A: before");
    await next();
    Console.WriteLine("A: after");
});

app.Use(async (ctx, next) =>
{
    Console.WriteLine("B: before");
    // 不呼叫 next() 就在這裡短路
    if (ctx.Request.Path.StartsWithSegments("/stop"))
    {
        await ctx.Response.WriteAsync("Stopped by B");
        return;
    }
    await next();
    Console.WriteLine("B: after");
});

app.Run(async ctx =>
{
    Console.WriteLine("C: terminal");
    await ctx.Response.WriteAsync("Hello from C");
});
```

* `/stop` 會在 B 停下，**不會**到 C。
* 其他路徑：A(before) → B(before) → C → B(after) → A(after)

**Map 與 MapWhen：分支管線**

```csharp
// /api 開一條支線
app.Map("/api", branch =>
{
    branch.Run(async ctx => await ctx.Response.WriteAsync("API branch"));
});

// 依條件分支（例如：含特定標頭）
app.MapWhen(ctx => ctx.Request.Headers.ContainsKey("X-Debug"), branch =>
{
    branch.Use(async (ctx, next) =>
    {
        ctx.Response.Headers["X-Branch"] = "debug";
        await next();
    });
    branch.Run(async ctx => await ctx.Response.WriteAsync("Debug branch"));
});
```

### 常見管線片段（建議順序）

1. 例外處理（`UseDeveloperExceptionPage`/全域錯誤處理）
2. HTTPS 轉向、HSTS
3. 靜態檔案（如需）
4. 路由（`UseRouting`）
5. CORS
6. 驗證（`UseAuthentication`）
7. 授權（`UseAuthorization`）
8. 快取/壓縮（如需）
9. 端點（`UseEndpoints` / MapControllers）

---

## 1.5 實作演練：從零建置可驗證的管線

🧪 目標：建立一個能看見「順序與短路」效果的可執行範例。

**Startup.Configure（節錄）**

```csharp
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment()) app.UseDeveloperExceptionPage();

    // 1) 全域日誌中介軟體（觀察順序）
    app.Use(async (ctx, next) =>
    {
        var sw = Stopwatch.StartNew();
        await next();
        sw.Stop();
        Console.WriteLine($"{ctx.Request.Method} {ctx.Request.Path} - {sw.ElapsedMilliseconds}ms");
    });

    app.UseRouting();

    // 2) 簡易 API 分支
    app.Map("/api", api =>
    {
        api.Use(async (ctx, next) =>
        {
            ctx.Response.Headers["X-Powered-By"] = "AspNetCore5";
            await next();
        });

        api.Run(async ctx =>
        {
            await ctx.Response.WriteAsync("Hello API");
        });
    });

    // 3) 一條會短路的支線
    app.Map("/health", branch =>
    {
        branch.Run(async ctx => await ctx.Response.WriteAsync("OK"));
    });

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
}
```

**測試結果**

* `GET /health` → 直接回「OK」，且不會進入 Controllers。
* `GET /api` → 會加上 `X-Powered-By: AspNetCore5`，內容「Hello API」。
* 其他路徑 → 落到 MVC 控制器或 404。

---

## 1.6 實作演練：DI + Options + Controller 串在一起

🧪 目標：把本章重點全部串聯驗證。

**appsettings.Development.json**

```json
{
  "Greeting": { "Message": "Hello, Dev!", "From": "Trainer" }
}
```

**Options 類別與服務**

```csharp
public class GreetingOptions
{
    public string Message { get; set; } = "Hello";
    public string From { get; set; } = "System";
}

public interface IGreetingService
{
    string Greet(string name);
}

public class GreetingService : IGreetingService
{
    private readonly IOptionsMonitor<GreetingOptions> _opt;
    private readonly IClock _clock; // 來自前面小節的 IClock

    public GreetingService(IOptionsMonitor<GreetingOptions> opt, IClock clock)
    {
        _opt = opt;
        _clock = clock;
    }

    public string Greet(string name)
    {
        var o = _opt.CurrentValue; // 支援變更即時生效
        return $"{o.Message}, {name}! - from {o.From} at {_clock.Now():u}";
    }
}
```

**Startup.ConfigureServices（整合註冊）**

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();

    // Options 綁定 & 監聽變更
    services.Configure<GreetingOptions>(Configuration.GetSection("Greeting"));

    // DI：跨章節沿用的 IClock
    services.AddTransient<IClock, SystemClock>();

    // 主要的應用服務
    services.AddScoped<IGreetingService, GreetingService>();
}
```

**控制器（驗證所有拼裝）**

```csharp
[ApiController, Route("api/greet")]
public class GreetingController : ControllerBase
{
    private readonly IGreetingService _svc;
    public GreetingController(IGreetingService svc) => _svc = svc;

    [HttpGet("{name}")]
    public IActionResult Get(string name)
    {
        var text = _svc.Greet(name);
        return Ok(new { text });
    }
}
```

**動手測試**

* 修改 `appsettings.Development.json` 的 `Greeting.Message` 或 `From`，儲存後重整 `GET /api/greet/Ada`，你會看到回應即時反映變更（`IOptionsMonitor`）。

---

## 1.7 小抄與檢核清單

✅ **專案啟動路徑**：`Program` 建主機 → `Startup.ConfigureServices` → `Startup.Configure` → Kestrel 接客
✅ **DI 原則**：預設選 Scoped；跨請求共享才用 Singleton（務必確保執行緒安全）
✅ **組態優先次序**：`appsettings` < `appsettings.{Env}` < User Secrets < 環境變數 < 命令列
✅ **管線順序**：Routing 前的東西（例外處理/靜態檔）→ `UseRouting` → Auth → `UseEndpoints`
✅ **短路行為**：`Run` 會停止往下傳遞；`Map/MapWhen` 會開分支；`Use` 可前後夾擊

---