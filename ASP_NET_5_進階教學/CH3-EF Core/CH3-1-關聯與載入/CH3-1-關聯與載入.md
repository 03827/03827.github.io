
---

# Chapter 1｜關聯與載入：把資料抓「剛剛好」

這章的關鍵目標：**用最適合的載入策略，抓到剛好需要的資料，既不過少（N+1 地獄）也不過多（笛卡兒爆炸）。**

我們會逐步示範：

1. 模型與關聯
2. Eager Loading：`Include/ThenInclude`（含 **多重 Include**、**Filtered Include**、**排序**、**投影**）
3. Explicit Loading：顯式載入（`Entry(...).Reference/Collection`）
4. Lazy Loading：延遲載入（代理）
5. **Split Queries vs Single Query**（EF Core 5 預設為 **Single**，可 opt-in Split）
6. 常見陷阱與效能基準心法（N+1 監測、分頁與集合 Include 的誤區、序列化陷阱）

---

## 1. 基礎模型與 DbContext

先定義常見的一對多樹狀：`Customer` → `Order` → `OrderItem` → `Product`。另外放一個 `RowVersion`（樂觀併發）為後續章節鋪路。

```csharp
public class Customer {
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public ICollection<Order> Orders { get; set; } = new List<Order>();
}

public class Order {
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; }
    public int CustomerId { get; set; }
    public Customer Customer { get; set; } = default!;
    public ICollection<OrderItem> Items { get; set; } = new List<OrderItem>();

    [Timestamp]                      // 樂觀鎖（後續章節會用）
    public byte[] RowVersion { get; set; } = default!;
}

public class OrderItem {
    public int Id { get; set; }
    public int OrderId { get; set; }
    public Order Order { get; set; } = default!;
    public int ProductId { get; set; }
    public Product Product { get; set; } = default!;
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }    
}

public class Product {
    public int Id { get; set; }
    public string Sku { get; set; } = default!;
    public string Name { get; set; } = default!;
    public decimal Price { get; set; }
}

public class AppDbContext : DbContext
{
    public DbSet<Customer> Customers => Set<Customer>();
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<OrderItem> OrderItems => Set<OrderItem>();
    public DbSet<Product> Products => Set<Product>();

    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

    protected override void OnModelCreating(ModelBuilder b)
    {
        b.Entity<Order>()
         .HasMany(o => o.Items)
         .WithOne(i => i.Order)
         .HasForeignKey(i => i.OrderId);

        b.Entity<OrderItem>()
         .HasOne(i => i.Product)
         .WithMany()
         .HasForeignKey(i => i.ProductId);
    }
}
```

---

## 2. Eager Loading：`Include` / `ThenInclude`（一次把需要的都拿回來）

### 2.1 基本 Include / ThenInclude

```csharp
// 取出某客戶最近的訂單，含每筆訂單的明細與對應商品
var orders = await ctx.Orders
    .Where(o => o.CustomerId == customerId)
    .OrderByDescending(o => o.CreatedAt)
    .Include(o => o.Items)
        .ThenInclude(i => i.Product)
    .ToListAsync();
```

**翻譯重點**：EF Core 5 預設使用 **Single Query**（一個大 JOIN）。多層集合 Include 會產生大量重複列（笛卡兒乘積），列表越大越容易「爆」。

### 2.2 多重 Include（兄弟關聯一起載）

```csharp
// 同時載入 Customer 與 Items→Product
var orders = await ctx.Orders
    .Where(o => o.CreatedAt >= DateTime.UtcNow.AddDays(-7))
    .Include(o => o.Customer)
    .Include(o => o.Items)
        .ThenInclude(i => i.Product)
    .ToListAsync();
```

> **順序不影響結果**，EF 會合併成單一查詢（Single）或多查詢（Split），視你設定而定（見後述）。

### 2.3 Filtered Include（EF Core 5 新增！在 Include 上直接篩選/排序/截取集合）

**情境**：只要「每張訂單**最新 5 筆**明細」，並按金額排序。

```csharp
var orders = await ctx.Orders
    .Where(o => o.CustomerId == customerId)
    .OrderByDescending(o => o.CreatedAt)
    .Include(o => o.Items
        .OrderByDescending(i => i.UnitPrice * i.Quantity)
        .Take(5))
    .ToListAsync();
```

> Filtered Include **只作用於集合導覽**（`ICollection<T>`），而且只影響**載入的子集合內容**，不會改動主查詢的過濾。

### 2.4 投影（Projection）vs Include：用 `Select` 只取你要的欄位

當你**不需要完整實體**（尤其是列表頁），**投影成 DTO 通常更快更省記憶體**：

```csharp
var dtos = await ctx.Orders
    .Where(o => o.CustomerId == customerId)
    .OrderByDescending(o => o.CreatedAt)
    .Select(o => new OrderListDto {
        OrderId = o.Id,
        CreatedAt = o.CreatedAt,
        CustomerName = o.Customer.Name,
        TopItems = o.Items
            .OrderByDescending(i => i.UnitPrice * i.Quantity)
            .Take(3)
            .Select(i => new OrderItemDto {
                ProductName = i.Product.Name,
                Qty = i.Quantity,
                Total = i.UnitPrice * i.Quantity
            })
            .ToList()
    })
    .AsNoTracking()
    .ToListAsync();
```

**實務心法**：

* **讀寫表單**需要追蹤狀態 → Include 載入實體。
* **報表/清單**只展示 → Projection（`Select`）＋ `AsNoTracking()` 最穩。

---

## 3. Explicit Loading：顯式載入（你說要，才去拿）

顯式載入把控制權交還給你：先抓主體，再按需載入某些導覽。

```csharp
var order = await ctx.Orders.FindAsync(orderId);

// 需要時才載入 Items（集合），但不能用在 AsNoTracking()的語法上。
//.Collection or . Reference
await ctx.Entry(order).Collection(o => o.Items).LoadAsync();

// 其中又需要 Product（參照）
await ctx.Entry(order).Collection(o => o.Items)
         .Query()                          // 可加條件！
         .Where(i => i.Quantity >= 5)
         .Include(i => i.Product)          // 顯式載入也能搭配 Include（透過 Query()）
         .LoadAsync();
```

**什麼時候用？**

* 後台「編輯單一主檔」：頁面互動決定要載入哪些子集合，顯式載入最細膩。
* 想避免延遲載入造成看不見的多次 round trip 時。

---

## 4. Lazy Loading：延遲載入（存取屬性時才去查）

**優點**：開發快速、寫起來很像「在記憶體的物件」。
**風險**：不小心在清單上迭代，導致 **N+1 查詢**；序列化時也可能偷偷觸發 DB。

### 4.1 啟用步驟（EF Core 5）

1. 要延遲載入的導覽屬性標為 `virtual`

```csharp
public class Order {
    public int Id { get; set; }
    public virtual Customer Customer { get; set; } = default!;
    public virtual ICollection<OrderItem> Items { get; set; } = new List<OrderItem>();
}

//這裡 Query 1 次
var orders = await _context.Orders.ToListAsync();

// 這裡會跟資料庫連線 N 次，產生 N 個額外的查詢
foreach (var order in orders)
{
    var itemCount = order.OrderItems.Count; // 觸發一個新的資料庫查詢
}

//這樣就是 N+1 問題。
```

**最佳實務**：

* 列表頁、報表頁**禁用** Lazy（容易 N+1），改用 Include 或投影。
* 序列化前把 Lazy Proxy 斷掉（或回傳 DTO）；否則可能在序列化過程中又連線 DB。

---

## 5. Split Queries vs Single Query（**EF Core 5 預設 Single**）

### 5.1 背景

* **Single Query**：把所有 Include 全包進一個大 SQL（多 JOIN）。

  * 優點：一次往返；有時更快。
  * 缺點：多個集合 Include 容易「笛卡兒乘積」→ 記憶體/網路流量爆漲。
* **Split Queries**：拆成多個 SQL（主體一個查詢 + 每個集合一個查詢），EF 在記憶體重組。

  * 優點：避免笛卡兒乘積，對「多集合、樹狀」場景更穩定。
  * 缺點：多次 round-trip；需要關聯鍵在記憶體做 merge。

> 在 **EF Core 5**：**預設是 Single**。你可以用 `AsSplitQuery()` 或全域設定切成 Split。
> 在 **EF Core 6+**：微調了預設行為（更偏 Split 以避免乘積爆炸）。

### 5.2 寫法

```csharp
// 單次查詢（預設 EF Core 5）
var result1 = await ctx.Orders
    .Include(o => o.Items).ThenInclude(i => i.Product)
    .ToListAsync();

// 指定 Split
var result2 = await ctx.Orders
    .Include(o => o.Items).ThenInclude(i => i.Product)
    .AsSplitQuery()
    .ToListAsync();

// 全域設定（在 AddDbContext 時）
services.AddDbContext<AppDbContext>(opt =>
    opt.UseSqlServer(connString, o =>
        o.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)));
```

**經驗法則**：

* 多個**集合** Include（`Order.Items`、`Order.Tags`、`Order.Histories`…）→ **AsSplitQuery** 較穩。
* 單一集合、或只有參照（`Include(o => o.Customer)`）→ 多半 **Single** 更快。

---

## 6. 整合範例：三種載入策略在同一 Use Case

**情境**：

* 後台「訂單清單頁」：顯示最近 30 天、每張訂單只秀前 3 筆金額最高的明細（商品名/數量/小計）。
* 點進「訂單詳情頁」：載完整主檔＋所有明細＋商品。
* 在詳情頁中，使用者展開「更多商品資訊」時，再載入 `Product` 的其他延伸屬性。

**清單頁（投影 + Filtered Include 或純投影）**：

```csharp
var list = await ctx.Orders
    .Where(o => o.CreatedAt >= DateTime.UtcNow.AddDays(-30))
    .OrderByDescending(o => o.CreatedAt)
    .Select(o => new OrderListDto {
        OrderId = o.Id,
        CreatedAt = o.CreatedAt,
        CustomerName = o.Customer.Name,
        TopItems = o.Items
            .OrderByDescending(i => i.UnitPrice * i.Quantity)
            .Take(3)
            .Select(i => new OrderItemDto {
                ProductName = i.Product.Name,
                Qty = i.Quantity,
                Total = i.UnitPrice * i.Quantity
            }).ToList()
    })
    .AsNoTracking()
    .ToListAsync();
```

**詳情頁（Include + 視情況 Split）**：

```csharp
var detail = await ctx.Orders
    .Where(o => o.Id == orderId)
    .Include(o => o.Customer)
    .Include(o => o.Items)
        .ThenInclude(i => i.Product)
    .AsSplitQuery() // 訂單明細多時較穩定
    .SingleOrDefaultAsync();
```

**詳情頁內的「更多商品資訊」按需載入（Explicit）**：

```csharp
// 使用者點開第 N 筆明細的延伸資訊（假設 Product.ExtraSpec 是延伸導覽）
var item = detail!.Items.First(x => x.Id == itemId);

// 只在需要時才載入延伸資訊
await ctx.Entry(item.Product).Reference("ExtraSpec").LoadAsync();
```

---

## 8. 速查表（這章精華壓縮）

* **列表/報表**：投影 `Select` + `AsNoTracking()`；必要時 Filtered Include 裁剪子集合。
* **編輯/維護**：`Include`（或顯式載入）拿到完整實體，避免錯誤使用 Lazy Load，在你看不到之處重複多次與 DB 連線查詢。
* **多集合樹狀**：`AsSplitQuery()` 比較安全；簡單平坦用 Single 可能更快。
* **要分頁基本是對主體分頁**；子集合分頁請改用 Filtered Include 或投影。

---

