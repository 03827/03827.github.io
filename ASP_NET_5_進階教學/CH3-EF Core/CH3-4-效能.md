# Chapter 4｜效能最佳化（Performance Optimization）

## 4.1 觀念導入：EF Core 效能瓶頸在哪裡？

EF Core 在高層抽象下，提供了方便的 ORM 功能，但每一層都可能帶來代價：

| 成本來源                      | 描述                      | 常見徵狀                 |
| ------------------------- | ----------------------- | -------------------- |
| **Change Tracker（變更追蹤器）** | 用於追蹤實體狀態（新增、修改、刪除）。     | 記憶體暴增、SaveChanges 變慢 |
| **查詢轉譯與執行計劃產生**           | LINQ → SQL 的翻譯過程 + 查詢分析 | 熱點查詢耗時明顯             |
| **單筆寫入 (N+1 Inserts)**    | 每筆都執行獨立 INSERT          | 批次寫入速度極慢             |
| **資料傳輸量過大**               | 不必要欄位或重複 JOIN           | 查詢慢、記憶體消耗高           |
| **追蹤圖過深**                 | Include 太多層級            | GC 壓力、快取溢出           |

本章的目標：
讓 EF Core 保持「語意完整」但接近「手寫 SQL」的速度。

---

## 4.2 Change Tracker（變更追蹤器）

### 什麼是 Change Tracker？

每個 `DbContext` 都維護一個「快照表」：
它記錄了從資料庫抓出的每個實體目前的屬性值、原始值、狀態（Added、Modified、Deleted、Unchanged）。
`SaveChanges()` 會比對這張快照表，生成對應的 SQL。

這是方便但昂貴的：追蹤越多實體 → 記憶體越大、比對越慢。

---

### 4.2.1 `AsNoTracking()`：只讀查詢加速武器

如果你只是「顯示資料、報表、下拉選單」而不會修改，就該禁用追蹤器。

```csharp
var list = await ctx.Products
    .AsNoTracking()
    .Where(p => p.Price > 100)
    .ToListAsync();
```

**效果：**

* 查詢結果不會進入 Change Tracker。
* 記憶體占用下降 60~90%。
* SaveChanges() 不再考慮這些實體。

---

### 4.2.2 `AsNoTrackingWithIdentityResolution()`

適用於有多層 `Include()` 的查詢。
如果同一個實體被多次 Include 到不同路徑，`AsNoTracking()` 會重複建立多個實例。
`AsNoTrackingWithIdentityResolution()` 能確保同一主鍵的實體只建一次。

```csharp
var orders = await ctx.Orders
    .AsNoTrackingWithIdentityResolution()
    .Include(o => o.Customer)
    .Include(o => o.Items).ThenInclude(i => i.Product)
    .ToListAsync();
```

> ✅ 仍是「不追蹤」，但會維持引用一致性。

---

### 4.2.3 關閉全域追蹤器(*但不建議這樣做*)

可在 Context 層面全域設定：

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
}
```

> 適合只讀應用（例如報表服務），但若要修改資料，需用 `Attach()` 手動附加。

---

## 4.3 批次寫入（Batching）

EF Core 會自動把多筆 Insert/Update 合併成一個 SQL 批次。
但若每次都呼叫 `SaveChanges()`，就會拆成多批，效能會崩。

---

### 4.3.1 錯誤範例（逐筆 SaveChanges）

```csharp
foreach (var p in products)
{
    ctx.Products.Add(p);
    await ctx.SaveChangesAsync(); // ❌ 每次都開交易 + 發送 SQL
}
```

這會造成：

* 每筆開關交易；
* 每筆網路 round-trip；
* 每筆執行查詢最佳化。

---

### 4.3.2 正確範例（單次 SaveChanges 一批資料）

```csharp
ctx.Products.AddRange(products);
await ctx.SaveChangesAsync();
```

這樣 EF Core 會生成批次 SQL，例如（SQL Server）：

```sql
INSERT INTO [Products] ([Name],[Price]) VALUES ('A',10.0);
INSERT INTO [Products] ([Name],[Price]) VALUES ('B',15.0);
INSERT INTO [Products] ([Name],[Price]) VALUES ('C',20.0);
```

你可以用 `MaxBatchSize()` 控制一次最多多少語句合併：

```csharp
services.AddDbContext<AppDbContext>(opt =>
    opt.UseSqlServer(connString, o => o.MaxBatchSize(200)));
```

⚠️如果是操作「大量資料」也還是避免這樣使用。

---

### 4.3.3 大量資料建議：第三方批次套件

EFCore 內建批次寫入適合幾百筆。
如果你要匯入上萬筆資料，建議使用：

* [EFCore.BulkExtensions](https://github.com/borisdj/EFCore.BulkExtensions)
範例：

```csharp
await ctx.BulkInsertAsync(bigList);
await ctx.BulkUpdateAsync(bigList);
```

> **注意**：第三方 Bulk 套件通常直接用 ADO.NET / SqlBulkCopy 寫入，會跳過 Change Tracker 與驗證邏輯。
> 請確保輸入資料完整無誤。

---

## 4.4 Compiled Queries（預編譯查詢快取）

EF Core 的 LINQ 查詢會在第一次執行時解析成 SQL，
這個轉譯過程雖然快，但在高頻查詢（例如首頁、排行榜）會造成重複開銷。

解法：**Compiled Queries**

---

### 4.4.1 定義 Compiled Query

```csharp
static readonly Func<AppDbContext, int, IAsyncEnumerable<Order>> _ordersByCustomer =
    EF.CompileAsyncQuery((AppDbContext db, int customerId) =>
        db.Orders
          .Where(o => o.CustomerId == customerId)
          .Include(o => o.Items)
          .OrderByDescending(o => o.CreatedAt));
```

使用：

```csharp
await foreach (var o in _ordersByCustomer(ctx, 5))
{
    Console.WriteLine(o.Id);
}
```

> ✅ EF Core 會只在第一次執行時轉譯 SQL，之後直接重用查詢計劃。

---

### 4.4.2 使用場景

| 場景                | 是否適用         |
| ----------------- | ------------ |
| API 熱點查詢（排行榜、儀表板） | ✅ 非常適合       |
| 單次使用的動態查詢         | ❌ 不建議（預編譯無效） |
| 查詢條件固定、執行頻繁       | ✅ 建議使用       |
| 條件複雜、動態拼接         | ❌ 不適合        |

---

### 4.4.3 EF 內部快取 vs Compiled Query

EF 其實會自動對重複查詢做「查詢快取」，但識別依據是「整個 Lambda 結構」。
如果 Lambda 動態生成（例如多條件組合），快取就會失效。
Compiled Query 明確保證可重複使用。

---

## 4.5 Query Pipeline：如何讓查詢更快

### 4.5.1 僅取必要欄位（投影）

```csharp
var list = await ctx.Products
    .Where(p => p.Price > 100)
    .Select(p => new { p.Id, p.Name })
    .ToListAsync();
```

> ✅ 減少傳輸量、記憶體壓力。
> ❌ `Include()` 會把整個物件抓回來，投影更精準。

---

### 4.5.2 分頁查詢加上索引排序

```csharp
var page = await ctx.Orders
    .OrderByDescending(o => o.CreatedAt)
    .Skip((pageIndex - 1) * pageSize)
    .Take(pageSize)
    .AsNoTracking()
    .ToListAsync();
```

確保排序欄位 (`CreatedAt`) 有索引，否則分頁會掃全表。

---

### 4.5.3 使用 Split Query 防止笛卡兒爆炸

```csharp
var orders = await ctx.Orders
    .Include(o => o.Items).ThenInclude(i => i.Product)
    .AsSplitQuery()
    .ToListAsync();
```

這樣 EF 會發出多個查詢，減少資料重複。
詳見 Chapter 1 的 `AsSplitQuery()` 解說。

---

## 4.6 SaveChanges() 效能微調

每次 `SaveChanges()` 都會：

1. 掃描 Change Tracker；
2. 分析實體狀態；
3. 建立 SQL；
4. 開交易；
5. 提交。

如果你頻繁 SaveChanges，可以：

### 4.6.1 批次 SaveChanges

將多個變更集合成一次：

```csharp
// ❌
await ctx.SaveChangesAsync();
await ctx.SaveChangesAsync();

// ✅
await ctx.SaveChangesAsync(acceptAllChangesOnSuccess: false);
ctx.ChangeTracker.AcceptAllChanges();
```

這能手動控制「變更標記清空」時機，避免重掃全部追蹤項。

---

### 4.6.2 關閉自動偵測變更（AutoDetectChanges）

預設每次 `Add()`、`Remove()`、`Update()` 都會觸發 `DetectChanges()`。
對大量操作會很慢。

```csharp
ctx.ChangeTracker.AutoDetectChangesEnabled = false;

foreach (var item in items)
    ctx.Products.Add(item);

ctx.ChangeTracker.AutoDetectChangesEnabled = true;
await ctx.SaveChangesAsync();
```

---

## 4.7 結合追蹤模式與投影：雙管齊下

範例：顯示報表時需要上千筆資料，但只需少數欄位。

```csharp
var result = await ctx.Orders
    .AsNoTracking()
    .Where(o => o.CreatedAt > DateTime.UtcNow.AddMonths(-1))
    .Select(o => new {
        o.Id,
        Customer = o.Customer.Name,
        Total = o.Items.Sum(i => i.Quantity * i.UnitPrice)
    })
    .ToListAsync();
```

**優點：**

* 不追蹤實體；
* 只回傳必需欄位；
* 聚合在 SQL 端完成（`SUM()` 在資料庫執行）。

---

## 4.8 查詢快取與冷啟動優化

在高併發系統，冷啟動階段（第一次 LINQ 查詢）會造成 CPU 峰值。
可以在應用程式啟動時「預熱」常用查詢。

```csharp
public static async Task WarmUp(AppDbContext ctx)
{
    _ = await ctx.Products.Take(1).ToListAsync();
    _ = await ctx.Orders.Take(1).ToListAsync();
}
```

這樣能讓 EF 提前建立查詢計劃與模型快取。

---

## 4.9 整合範例：高效查詢與寫入模板

```csharp
public async Task<IEnumerable<OrderSummary>> GetRecentOrders(AppDbContext ctx, int days)
{
    // 查詢模板：投影 + NoTracking + SplitQuery
    var query = ctx.Orders
        .AsNoTracking()
        .AsSplitQuery()
        .Where(o => o.CreatedAt >= DateTime.UtcNow.AddDays(-days))
        .Select(o => new OrderSummary {
            Id = o.Id,
            CustomerName = o.Customer.Name,
            ItemCount = o.Items.Count,
            Total = o.Items.Sum(i => i.Quantity * i.UnitPrice)
        });

    return await query.ToListAsync();
}

public async Task BulkCreateOrders(AppDbContext ctx, IEnumerable<Order> orders)
{
    // 批次寫入模板
    ctx.ChangeTracker.AutoDetectChangesEnabled = false;
    ctx.Orders.AddRange(orders);
    await ctx.SaveChangesAsync();
    ctx.ChangeTracker.AutoDetectChangesEnabled = true;
}
```

---

## 4.10 效能最佳化清單（速查）

| 項目         | 策略                                                 |
| ---------- | -------------------------------------------------- |
| **查詢讀取**   | 使用 `AsNoTracking()`、`Select()` 投影、`AsSplitQuery()` |
| **查詢快取**   | 熱點查詢用 `EF.CompileQuery()`                          |
| **大量新增**   | 使用 `AddRange()` + 單次 `SaveChanges()`               |
| **大量更新**   | 關閉 `AutoDetectChangesEnabled`，必要時用 Bulk 套件         |
| **批次大小**   | 設定 `MaxBatchSize()`                                |
| **記憶體控制**  | 避免深層 Include，使用投影                                  |
| **冷啟動加速**  | 啟動時預熱查詢                                            |
| **模型快取**   | 使用共用 DbContextOptions                              |
| **死結與鎖競爭** | 保持交易短、順序一致（Chapter 3）                              |

---

## 4.11 小結

EF Core 效能優化的核心哲學是：

> “讓 EF 只做該做的事，別讓它做多餘的。”

1. **讀取階段 → 關掉追蹤器**。
2. **寫入階段 → 批次處理**。
3. **查詢階段 → 投影、Split Query、快取重用**。
4. **頻繁操作 → 預編譯 (Compiled Query)**。
5. **大規模資料 → 直接 Bulk。**

---

下一章（Chapter 5）將會講解
「**查詢翻譯與 SQL 映射：如何避免 Client Evaluation、使用 FromSqlRaw、映射視圖與函數、以及 IQueryable 擴充技巧**」，
這是讓 EF Core 在複雜查詢下保持“能翻成 SQL、跑在資料庫端”的關鍵。
要我直接展開 Chapter 5 嗎？
